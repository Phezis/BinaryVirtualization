# Virtual Pointer

## Вкратце о виртуальном указателе

Идея виртуального указателя состоит в обеспечении последовательного доступа до фрагментированной памяти с наибольшим приближением интерфейса к интерфейсу стандартных указателей языка.

Виртуальный указатель получает указатели на фрагменты, до которых необходимо предоставить последовательный доступ, причем в той последовательности, в которой они будут переданы. 

Указатели на переданные фрагменты должны быть действительны на протяжении всей жизни виртуального указателя.

Копия указателя ссылается на те же фрагменты, что и оригинал; изменение структуры фрагментов (добавление нового фрагмента) оригинального указателя влечет за собой аналогичные изменения структуры фрагментов копии (и наоборот).

Указатель представляет из себя индекс элемента в формируемой добавляемыми фрагментами последовательной памяти, сдвиг указателя меняет индекс в этой памяти. Добавление нового фрагмента воспринимается как расширение доступной памяти в сторону увеличения индексов.

## Интерфейс
### Конструктор

    VirtualPointer();                                   (1)
    VirtualPointer(const VirtualPointer& other);        (2)
    VirtualPointer(VirtualPointer&& other) noexcept;    (3)

1) Создает пустой виртуальный указатель.
2) Создает объект, копируя состояние переданного в качестве параметра виртуального указателя. Во время выполнения происходит копирование указателя на структуру данных, хранящую все добавленные сегменты, таким образом, копирование происходит достаточно быстро, при этом все копии имеют указатель на один участок памяти, поэтому добавление новых сегментов одному из них приведет к появлению этого сегмента во всех остальных копиях.
3) Создает объект, перемещая состояние переданного в качестве параметра виртуального указателя.

### Деструктор
	~VirtualPointer() noexcept;       (1)
	
1) Определен стандартный деструктор.

### Оператор присваивания
	VirtualPointer& operator=(const VirtualPointer& other);     (1)
	VirtualPointer& operator=(VirtualPointer&& other) noexcept; (2)

1)  Определен стандартный оператор копирующего присваивания
2)  Определен стандартный оператор перемещающего присваивания

### Добавление и удаление фрагментов

	void addChunk(T* ptr, std::size_t length);                      (1)
	void addChunk(const VirtualPointer& src, std::size_t count);    (2)
	void clear();                                                   (3)

1) Запоминает очередной сегмент с началом в ptr размера length. Размер length понимается как количество элементов типа T, т.е. размер добавляемого фрагмента в байтах равен length*sizeof(T) байт.
2) Pапоминает один или несколько сегментов из src общей длиной count. В случае, когда src содержит меньше, чем count элементов, состояние объекта восстановится до первоначального и будет выброшено исключение std::out_of_range. Решение восстанавливать состояние объекта было принято для того, чтобы при перехвате и обработке ошибки и дальнейшей работе состояние объекта было определено
3) Сбрасывается до состояния после вызова стандартного конструктора. Существующие копии не изменят свое состояние.

### Арифметические операторы

	VirtualPointer& operator++();                                                       (1)
	VirtualPointer operator++(int);                                                     (2)
	VirtualPointer& operator+=(std::size_t shift);                                      (3)
	VirtualPointer& operator--();                                                       (4)
	VirtualPointer operator--(int);                                                     (5)
	VirtualPointer& operator+=(std::size_t shift);                                      (6)
	VirtualPointer& operator-=(std::size_t shift);                                      (7)
	
    VirtualPointer<T> operator+(VirtualPointer<T> ptr, const std::size_t& shift);       (8)
    VirtualPointer<T> operator+(const std::size_t& shift, VirtualPointer<T> ptr);       (9)
    VirtualPointer<T> operator-(VirtualPointer<T> ptr, const std::size_t& shift);       (10)

1) Префиксный инкремент, переход к следующему элементу типа T в представленной линейной памяти. Производит операцию над самим объектом, возвращает его же.
2) Постфиксный инкремент, создает объект – копию себя до изменения, производит переход к следующему элементу типа T, после чего возвращает сделанную заранее копию. Из-за дополнительного копирования работает медленнее, рекомендуется по возможности заменять на префиксный инкремент.
3) Смещается вперед на shift элементов типа T в представленной линейной памяти.
4) Префиксный декремент, переход к предыдущему элементу типа T в представленной линейной памяти. Производит операцию над самим объектом, возвращает его же.
5) Постфиксный декремент, создает объект – копию себя до изменения, производит переход к предыдущему элементу типа T, после чего возвращает сделанную заранее копию. Из-за дополнительного копирования работает медленнее, рекомендуется по возможности заменять на префиксный декремент.
6) Смещается вперед на shift элементов типа T в представленной линейной памяти. Скорость работы линейно зависит от количества фрагментов между текущей и искомой позицией.
7) Смещается назад на shift элементов типа T в представленной линейной памяти. Скорость работы линейно зависит от количества фрагментов между текущей и искомой позицией.
8) Бинарный оператор сложения. Во время исполнения создается копия ptr, которая смещается на shift элементов типа T вперед, после чего возвращается в качестве результата.
9) Бинарный оператор сложения. Аналогичен (8)
10) Бинарный оператор разности. Создается копия ptr, которая смещается на shift элементов типа T назад, после чего возвращается в качестве результата. Из-за специфики виртуального указателя бинарный оператор <size_t - ptr> нереализуем.

Арифметические операторы позволяют выходить за пределы доступной памяти и возвращаться обратно. Например, пусть создан виртуальный указатель p и инициализирован фрагментом размера ***N > 0*** и пусть ***0 < x < N***. Тогда результат выполнения

    p += N + x;
    p -= 2*x;
    
аналогичен результату выполнения

    p += N - x;
    
Выход в отрицательную область тоже возможен: результат выполнения

    p -= x;
    p += 2*x;
    
аналогичен результату выполнения

    p += x;

### Разыменование

	T& operator*();                                 (1)
	T& operator[](std::size_t idx);                 (2)
	const T& operator[](std::size_t idx) const;     (3)

1. Разыменовывает указатель на элемент, на который указывает объект. Разыменование виртуального указателя, которому не было передано ни одного блока размера не менее 1, приводит к неопределенному поведению. Разыменование виртуального указателя, вышедшего за границу доступной ему памяти, приводит к неопределенному поведению.
2. Разыменовывают указатель на объект, смещенный на idx элементов относительно текущего положения указателя в виртуальном представлении. Аналогично созданию копии объекта, над которым затем последовательно применяются операторы operator+=(idx) и operator*(). Работает за линейное от количества фрагментов время.
3. Константный аналог (2)

### Дополнительные методы
	std::size_t bytesRemaining() const;             (1)
	bool isOverflow() const;                        (2)

1. Возвращает количество доступных байт от текущей позиции до последнего элемента последнего фрагмента включительно.
2. Возвращает true, если текущая позиция находится за границами доступной памяти, иначе false.

### Дополнительные функции

	template<typename T, typename V>
	VirtualPointer<T>& memset(VirtualPointer<T>& dest, const V& value, std::size_t count);                      (1)
	
    template<typename T>
	VirtualPointer<T>& memcpy(VirtualPointer<T>& dest, const VirtualPointer<T>& src, std::size_t count);        (2)
	
    template<typename T>
	VirtualPointer<T>& memcpy(VirtualPointer<T>& dest, const void* src, std::size_t count);                     (3)
	
    template<typename T>
	void* memcpy(void* dest, const VirtualPointer<T>& src, std::size_t count);                                  (4)
	
    template<typename T>
	VirtualPointer<T>& memmove(VirtualPointer<T>& dest, const VirtualPointer<T>& src, std::size_t count);       (5)
	
    template<typename T>
	VirtualPointer<T>& memmove(VirtualPointer<T>& dest, const void* src, std::size_t count);                    (6)
	
    template<typename T>
	void* memmove(void* dest, const VirtualPointer<T>& src, std::size_t count);                                 (7)
	
    template<typename T>
	int memcmp(const VirtualPointer<T>& dest, const VirtualPointer<T>& src, std::size_t count);                 (8)
	
    template<typename T>
	int memcmp(const VirtualPointer<T>& dest, const void* src, std::size_t count);                              (9)
	
    template<typename T>
	int memcmp(const void* dest, const VirtualPointer<T>& src, std::size_t count);                              (10)

1. Заполняет count элементов начиная с dest значением value. Возвращает dest. Если dest не содержит ни одного блока, будет выброшено исключение NullPointerException. Если во время выполнения dest выйдет за границу доступной памяти, будет выброшено исключение std::out_of_range.
2. Копирует count элементов из src в dest, возвращает dest. Если любой виртуальный указатель не содержит ни одного блока, будет выброшено исключение NullPointerException. Если во время выполнения любой виртуальный указатель выйдет за границу доступной памяти, будет выброшено исключение std::out_of_range, при этом состояние не восстановится до изначального.
3. Аналогичен (2)
4. Аналогичен (2)
5. Копирует count элементов из src в dest через временный буфер: сначала происходит копирования в буфер из src, затем из буфера происходит копирование в dest. Возвращает dest. Если любой виртуальный указатель не содержит ни одного блока, будет выброшено исключение NullPointerException. Если во время выполнения любой виртуальный указатель выйдет за границу доступной памяти, будет выброшено исключение std::out_of_range, при этом состояние не восстановится до изначального.
6. Аналогичен (5)
7. Аналогичен (5)
8. Сравнивает первые count элементов типа T, начиная с соответствующих dest и src мест. Если все элементы по указанным адресам совпадают, возвращает 0. Если первый различный символ в dest меньше, чем src, то вернется отрицательное значение, если больше – положительное. Если любой виртуальный указатель не содержит ни одного блока, будет выброшено исключение NullPointerException. Если во время выполнения любой виртуальный указатель выйдет за границу доступной памяти, будет выброшено исключение std::out_of_range.
9. Аналогичен (8)
10. Аналогичен (8)



## Потокобезопасность
Класс не является потокобезопасным.

## Использование
### Подключение
Для использования библиотеки достаточно использовать два заголовочных файла
- Exceptions.h
- VirtualPointer.h

### Пример использования
    #include <cstddef>
    #include <iostream>
    #include <VirtualPointer.h>
    
    int main() {
        using std::size_t;
        const size_t src1Size = 6;
        const size_t src2Size = 2;
        size_t src1[src1Size] = {};
        size_t src2[src2Size] = {};
        auto vptr = VirtualPointer<size_t>();
        vptr.addChunk(src1, 4);
        vptr.addChunk(src2, 2);
    
        /*
            scr1 - 0 1 2 3 4 5 | 0 1 - src2
                   0 0 0 0 0 0 | 0 0
        */
        memset(vptr, 9, 6);
        /*
            scr1 - 0 1 2 3 4 5 | 0 1 - src2
                   9 9 9 9 0 0 | 9 9
        */
        *vptr = 1; // запишем в самое начало 1
        /*
            scr1 - 0 1 2 3 4 5 | 0 1 - src2
                   1 9 9 9 0 0 | 9 9
        */
        ++vptr; // сместимся вперед
        *vptr = 1;
        /*
            scr1 - 0 1 2 3 4 5 | 0 1 - src2
                   1 1 9 9 0 0 | 9 9
        */
        vptr += 3;
        *vptr = 5;
        /*
            scr1 - 0 1 2 3 4 5 | 0 1 - src2
                   1 1 9 9 0 0 | 5 9
        */
    
        vptr -= 4; // вернемся в начало для вывода
    
        std::cout << "Virtual:" << "\n\t";
        for (int i = 0; i < 6; ++i) {
            std::cout << *vptr << "; ";
            ++vptr;
        }
    
        std::cout << std::endl << "src1:" << "\n\t";
        for (int i = 0; i < src1Size; ++i) {
            std::cout << src1[i] << "; ";
            ++vptr;
        }
    
        std::cout << std::endl << "src2:" << "\n\t";
        for (int i = 0; i < src2Size; ++i) {
            std::cout << src2[i] << "; ";
            ++vptr;
        }
    
        return 0;
    }
 
Вывод:

    Virtual:
        1; 1; 9; 9; 5; 9;
    src1:
        1; 1; 9; 9; 0; 0;
    src2:
        5; 9;
